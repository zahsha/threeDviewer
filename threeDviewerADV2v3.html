<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic 3D Model Viewer - Advanced (Improved)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <style>
        body { 
            margin: 0; 
            font-family: 'Inter', sans-serif; 
            background-color: #f0f2f5; /* Light gray background for the page */
            color: #1a202c; /* Dark gray text */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden; /* Prevent horizontal scrollbars on the body */
        }
        .page-wrapper { 
            @apply w-full px-4 sm:px-6 lg:px-8;
            transition: opacity 0.2s ease-out, max-height 0.3s ease-out, visibility 0.3s step-end, padding 0.3s ease-out, margin 0.3s ease-out;
        }
        .page-wrapper.fullscreen-hide,
        #controlsWrapper.fullscreen-hide {
            opacity: 0 !important;
            pointer-events: none !important;
            max-height: 0px !important;
            overflow: hidden !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important; 
            visibility: hidden !important; 
            transition: opacity 0.2s ease-out, max-height 0.3s ease-out, visibility 0s 0.3s, padding 0.3s ease-out, margin 0.3s ease-out;
        }
        .main-controls-footer-container { 
             @apply w-full max-w-5xl mx-auto; /* Centered container for controls and footer */
        }
        #viewerContainer { 
            width: 100%; 
            height: 65vh; /* Default height for the viewer */
            position: relative; 
            overflow: hidden; 
            background-color: #e2e8f0; /* Slightly lighter gray for viewer background */
            border-radius: 0.5rem; /* Rounded corners for the viewer */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* Subtle shadow */
            transition: height 0.3s ease-out, top 0.3s ease-out, left 0.3s ease-out, border-radius 0.3s ease-out;
        }
        #viewerContainer.fullscreen-active {
            position: fixed !important; 
            top: 0 !important;
            left: 0 !important;
            height: 100vh !important; 
            width: 100vw !important; 
            z-index: 5000 !important; 
            border-radius: 0 !important; /* No rounded corners in fullscreen */
        }
        #backgroundImageElement {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; /* Cover the container, might crop */
            z-index: 0; /* Behind the canvas */
            transition: filter 0.2s ease-out;
        }
        canvas { 
            display: block; 
            position: relative; 
            z-index: 1; /* Above the background image */
        }
        .loader {
            border: 4px solid #cbd5e1; /* Light gray border */
            border-top: 4px solid #2563eb; /* Blue spinner part */
            border-radius: 50%;
            width: 40px; height: 40px;
            animation: spin 0.8s linear infinite;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10; /* Above canvas during loading */
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        .message-box {
            position: absolute; top: 1rem; left: 50%;
            transform: translateX(-50%) translateY(-20px); /* Start off-screen for entry animation */
            padding: 0.75rem 1.25rem; border-radius: 0.5rem;
            font-size: 0.875rem; font-weight: 500;
            z-index: 1000; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            pointer-events: none;
        }
        .message-box.show { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }
        .message-box.error { background-color: #ef4444; color: white; } /* Red for errors */
        .message-box.success { background-color: #22c55e; color: white; } /* Green for success */
        .message-box.info { background-color: #3b82f6; color: white; } /* Blue for info */
        
        .control-button {
            @apply flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2.5 px-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-150 ease-in-out text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75;
        }
        .control-button.secondary { @apply bg-gray-200 hover:bg-gray-300 text-gray-700 border border-gray-300; }
        .control-button.danger { @apply bg-red-500 hover:bg-red-600; }
        .control-button.success { @apply bg-green-500 hover:bg-green-600; }
        .input-field { @apply block w-full p-3 border border-gray-300 rounded-lg bg-white text-gray-700 placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors duration-150 shadow-sm; }
        .control-section { @apply mb-4 p-4 bg-gray-50 rounded-lg shadow; }
        .slider-container { @apply mt-4 p-4 bg-gray-100 rounded-lg shadow-inner; }
        .slider-group { @apply flex-1 min-w-[200px]; } 
        .slider-label { @apply block text-sm font-medium text-gray-600 mb-1.5 flex justify-between items-center; }
        .slider { @apply w-full h-2.5 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50; }
        .slider::-webkit-slider-thumb { @apply appearance-none w-5 h-5 bg-blue-600 rounded-full shadow-md cursor-pointer transition-transform duration-100 ease-in-out ring-2 ring-white; }
        .slider::-moz-range-thumb { @apply appearance-none w-5 h-5 bg-blue-600 rounded-full shadow-md cursor-pointer border-none ring-2 ring-white; }
        .hotkey-info { @apply text-xs text-gray-500 leading-relaxed; }
        .header-title {
             font-family: 'Orbitron', sans-serif; /* Futuristic font for the title */
             @apply text-3xl sm:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600;
             text-shadow: 1px 1px 2px rgba(0,0,0,0.1), 0 0 5px rgba(100,100,200,0.3), 0 0 10px rgba(150,100,250,0.2);
        }
    </style>
</head>
<body>
    <div class="page-wrapper mt-8" id="headerPageWrapper"> <div class="main-controls-footer-container">
            <header class="mb-6 sm:mb-8 text-center">
                <h1 class="header-title">3D Model Viewer Ultra</h1>
            </header>
            <div id="controlsWrapper" class="transition-all duration-300 ease-in-out">
                <div class="control-section">
                    <label for="modelUrlInput" class="block text-sm font-medium text-gray-600 mb-2">Load Model from URL (.glb, .gltf, .fbx, .obj, .stl)</label>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input type="text" id="modelUrlInput" class="input-field flex-grow" placeholder="https://example.com/model.glb">
                        <button id="loadUrlButton" class="control-button">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                            Load URL (L)
                        </button>
                    </div>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 gap-3 mb-4"> 
                    <button id="loadFileButton" class="control-button secondary">
                         <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M12 15l5-5m0 0l-5-5m5 5H3"></path></svg>
                        Load Device (O)
                    </button>
                    <input type="file" id="fileInput" accept=".glb,.gltf,.fbx,.stl,.obj" class="hidden">
                     <button id="centreButton" class="control-button secondary"> <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        Reset View (R)
                    </button>
                    <button id="changeViewButton" class="control-button secondary">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0zM21 12c-1.657 4.477-6.063 8-9 8s-7.343-3.523-9-8c1.657-4.477 6.063-8 9-8s7.343 3.523 9 8zM12 15a3 3 0 100-6 3 3 0 000 6z"></path></svg>
                        Change View (V)
                    </button>
                    <button id="sbsModeButton" class="control-button success">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                        Toggle SBS (S)
                    </button>
                    <button id="loadBgButton" class="control-button secondary">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                        Load BG (B)
                    </button>
                    <input type="file" id="bgImageInput" accept="image/*" class="hidden">
                    <button id="fullscreenButton" class="control-button secondary">
                         <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
                        Fullscreen (F)
                    </button>
                     <button id="brighterButton" class="control-button secondary">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                        Brighter (Sh+=)
                    </button>
                    <button id="darkerButton" class="control-button secondary">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                        Darker (Sh+-)
                    </button>
                    <button id="randomLightButton" class="control-button secondary">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        Random Light (Alt+L)
                    </button>
                </div>
                <div id="sbsSlidersContainer" class="hidden slider-container">
                    <div class="flex flex-col sm:flex-row gap-6">
                        <div class="slider-group"><label for="eyeSeparationSlider" class="slider-label"><span>Eye Separation (Sh+A/D)</span><span id="eyeSeparationValue" class="font-mono text-blue-600">0.064</span></label><input type="range" id="eyeSeparationSlider" min="0" max="0.2" step="0.001" value="0.064" class="slider"></div>
                        <div class="slider-group"><label for="focusDepthSlider" class="slider-label"><span>Focus Depth (Sh+W/S)</span><span id="focusDepthValue" class="font-mono text-blue-600">10.0</span></label><input type="range" id="focusDepthSlider" min="0.1" max="50" step="0.1" value="10" class="slider"></div>
                    </div>
                </div>
                <div id="bgBlurSliderContainer" class="hidden slider-container mt-4"> <div><label for="bgBlurSlider" class="slider-label"><span>Background Blur (Sh+Z/C)</span><span id="bgBlurValue" class="font-mono text-blue-600">0px</span></label><input type="range" id="bgBlurSlider" min="0" max="20" step="0.5" value="0" class="slider"></div></div>
                
                <div class="slider-container mt-4">
                    <div class="flex flex-col sm:flex-row gap-6">
                        <div class="slider-group">
                            <label for="brightnessSlider" class="slider-label">
                                <span>Overall Brightness (Sh+./M)</span>
                                <span id="brightnessValue" class="font-mono text-blue-600">1.0</span>
                            </label>
                            <input type="range" id="brightnessSlider" min="0" max="15" step="0.1" value="1.0" class="slider">
                        </div>
                        <div class="slider-group">
                            <label for="exposureSlider" class="slider-label">
                                <span>Scene Exposure (Sh+E/Q)</span>
                                <span id="exposureValue" class="font-mono text-blue-600">1.0</span>
                            </label>
                            <input type="range" id="exposureSlider" min="0.1" max="10" step="0.05" value="1.0" class="slider">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="viewerContainer">
        <img id="backgroundImageElement" src="#" alt="Custom background" style="display: none;" onerror="this.style.display='none'; console.warn('Background image failed to load or not set.')" />
        <div id="messageBox" class="message-box"></div>
        </div>

    <div class="page-wrapper mb-8" id="footerPageWrapper"> <div class="main-controls-footer-container">
            <footer class="mt-6 text-center">
                <p class="hotkey-info">Default Model: <a href="https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf" class="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">Damaged Helmet</a>. Orbit: LMB | Zoom: Scroll | Pan: RMB.</p>
                <p class="hotkey-info">Keys: Load URL (L), Load Device (O), Reset View (R), Change View (V), Load BG (B), SBS Mode (S), Fullscreen (F), Exit Fullscreen (Esc).</p>
                <p class="hotkey-info">Lighting: Brightness (Sh+. / Sh+M), Exposure (Sh+E / Sh+Q), Random Light Angle (Alt+L).</p>
                <p class="hotkey-info">Old Light Btns: Brighter (Sh+=), Darker (Sh+-). These now control Overall Brightness.</p>
                <p class="hotkey-info">SBS Controls: Eye Separation (Shift+A/D), Focus Depth (Shift+W/S). Background Blur: (Shift+Z/C).</p>
                <p class="hotkey-info">Supported File Formats: .glb, .gltf, .fbx (animations supported), .obj, .stl. For .obj, materials (.mtl) might need manual handling if not embedded or same-named.</p>
            </footer>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

        // Core Three.js variables
        let scene, camera, renderer, controls, stereoCamera, clock, mixer;
        let ambientLight, keyLight, fillLight; 
        let sbsMode = false; // Side-by-Side stereo mode flag
        let currentModel = null; // Reference to the currently loaded model
        let animationFrameId; // For managing the animation loop
        let isFullscreen = false; // Fullscreen mode flag
        let currentViewIndex = 0; // Index for cycling through predefined views
        let modelBoundingSphereRadius = 1; // Radius of the current model's bounding sphere
        let modelBoundingBox = new THREE.Box3(); // Box of the current model, centered and unscaled

        // DOM Element references
        const viewerContainer = document.getElementById('viewerContainer');
        const modelUrlInput = document.getElementById('modelUrlInput');
        const loadUrlButton = document.getElementById('loadUrlButton');
        const loadFileButton = document.getElementById('loadFileButton');
        const fileInput = document.getElementById('fileInput');
        const centreButton = document.getElementById('centreButton'); 
        const changeViewButton = document.getElementById('changeViewButton');
        const sbsModeButton = document.getElementById('sbsModeButton');
        const fullscreenButton = document.getElementById('fullscreenButton');
        const brighterButton = document.getElementById('brighterButton'); // Now controls overall brightness
        const darkerButton = document.getElementById('darkerButton');     // Now controls overall brightness
        const randomLightButton = document.getElementById('randomLightButton');
        const messageBox = document.getElementById('messageBox');
        const controlsWrapper = document.getElementById('controlsWrapper');
        const sbsSlidersContainer = document.getElementById('sbsSlidersContainer');
        const eyeSeparationSlider = document.getElementById('eyeSeparationSlider');
        const eyeSeparationValue = document.getElementById('eyeSeparationValue');
        const focusDepthSlider = document.getElementById('focusDepthSlider');
        const focusDepthValue = document.getElementById('focusDepthValue');
        const loadBgButton = document.getElementById('loadBgButton');
        const bgImageInput = document.getElementById('bgImageInput');
        const backgroundImageElement = document.getElementById('backgroundImageElement');
        const bgBlurSliderContainer = document.getElementById('bgBlurSliderContainer');
        const bgBlurSlider = document.getElementById('bgBlurSlider');
        const bgBlurValue = document.getElementById('bgBlurValue');
        const exposureSlider = document.getElementById('exposureSlider');
        const exposureValue = document.getElementById('exposureValue');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const brightnessValue = document.getElementById('brightnessValue');
        const headerPageWrapper = document.getElementById('headerPageWrapper');
        const footerPageWrapper = document.getElementById('footerPageWrapper');
        
        // Default model URL
        const defaultModelUrl = 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';
        modelUrlInput.value = defaultModelUrl;

        // Initial light intensity values (will be scaled by brightness slider)
        const initialAmbientIntensity = 0.8;
        const initialKeyLightIntensity = 1.2;
        const initialFillLightIntensity = 0.6;


        // Predefined camera view vectors (normalized)
        const viewVectors = [
            new THREE.Vector3(0, 0, 1),   // Front
            new THREE.Vector3(0, 0, -1),  // Back
            new THREE.Vector3(-1, 0, 0),  // Left
            new THREE.Vector3(1, 0, 0),   // Right
            new THREE.Vector3(0, 1, 0.001).normalize(), // Top (0.001 to avoid issues with lookAt if perfectly aligned)
            new THREE.Vector3(0, -1, 0.001).normalize(),// Bottom
            new THREE.Vector3(1, 1, 1).normalize(),  // Isometric Top-Right-Front
            new THREE.Vector3(-1, 1, 1).normalize()  // Isometric Top-Left-Front
        ];

        // --- Initialization Function ---
        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock(); // For animation updates
            
            // Main camera setup
            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 0.5, 2); // Initial position, will be overridden by performInitialFraming
            camera.focus = parseFloat(focusDepthSlider.value); // For SBS stereo camera

            // Stereo camera for SBS mode
            stereoCamera = new THREE.StereoCamera();
            stereoCamera.eyeSep = parseFloat(eyeSeparationSlider.value);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha for transparent background
            renderer.setClearColor(0x000000, 0); // Transparent clear color
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharp rendering on high DPI screens
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // For better HDR handling
            renderer.toneMappingExposure = parseFloat(exposureSlider.value); 
            renderer.outputColorSpace = THREE.SRGBColorSpace; // Correct color output
            viewerContainer.appendChild(renderer.domElement); // Add canvas to the container
            onWindowResize(); // Call once to set initial aspect correctly based on actual clientWidth/Height


            // OrbitControls setup
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05; // Smooth camera movement
            controls.target.set(0, 0, 0); // Initial target, will be updated by performInitialFraming
            controls.minDistance = 0.0001; // Allow very close zoom (will be refined by performInitialFraming)
            controls.maxDistance = Infinity; // Allow very far zoom out (will be refined by performInitialFraming)
            controls.screenSpacePanning = true; // Enable panning across the screen
            controls.update();
            
            // Lighting setup
            ambientLight = new THREE.AmbientLight(0xffffff, initialAmbientIntensity); scene.add(ambientLight);
            keyLight = new THREE.DirectionalLight(0xffffff, initialKeyLightIntensity); keyLight.position.set(-5, 5, 5); scene.add(keyLight);
            fillLight = new THREE.DirectionalLight(0xffffff, initialFillLightIntensity); fillLight.position.set(5, 2, 5); scene.add(fillLight);
            updateBrightness({target: brightnessSlider}); // Apply initial brightness from slider
            
            // Environment map for reflections and ambient lighting
            new RGBELoader()
                .setPath('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/textures/equirectangular/')
                .load('venice_sunset_1k.hdr', (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture; 
                }, undefined, (error) => console.warn("Could not load HDR environment map:", error));

            // Event Listeners
            loadUrlButton.addEventListener('click', () => loadModelFromUrl(modelUrlInput.value));
            loadFileButton.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            centreButton.addEventListener('click', resetView); 
            changeViewButton.addEventListener('click', cycleView);
            sbsModeButton.addEventListener('click', toggleSBSMode);
            fullscreenButton.addEventListener('click', toggleFullscreen);
            brighterButton.addEventListener('click', () => adjustBrightnessSlider(0.5)); // Corresponds to Sh+=
            darkerButton.addEventListener('click', () => adjustBrightnessSlider(-0.5));   // Corresponds to Sh+-
            randomLightButton.addEventListener('click', randomizeLightAngle);
            exposureSlider.addEventListener('input', updateExposure);
            brightnessSlider.addEventListener('input', updateBrightness);
            eyeSeparationSlider.addEventListener('input', updateEyeSeparation);
            focusDepthSlider.addEventListener('input', updateFocusDepth);
            loadBgButton.addEventListener('click', () => bgImageInput.click());
            bgImageInput.addEventListener('change', handleBgImageSelect);
            bgBlurSlider.addEventListener('input', updateBgBlur);
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeydown);
            document.addEventListener('fullscreenchange', handleFullscreenChange); // Standard API
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange); // Safari
            document.addEventListener('mozfullscreenchange', handleFullscreenChange); // Firefox
            document.addEventListener('MSFullscreenChange', handleFullscreenChange); // IE/Edge

            // Initialize slider display values
            eyeSeparationValue.textContent = parseFloat(eyeSeparationSlider.value).toFixed(3);
            focusDepthValue.textContent = parseFloat(focusDepthSlider.value).toFixed(1);
            bgBlurValue.textContent = `${parseFloat(bgBlurSlider.value).toFixed(1)}px`;
            exposureValue.textContent = parseFloat(exposureSlider.value).toFixed(2);
            brightnessValue.textContent = parseFloat(brightnessSlider.value).toFixed(2);


            // Load the default model
            loadModelFromUrl(defaultModelUrl); 
            animate(); // Start the animation loop
        }

        // --- UI Update Functions ---
        function showMessage(message, type = 'error', duration = 3500) {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type} show`; // Add 'show' to trigger animation
            setTimeout(() => { messageBox.classList.remove('show'); }, duration);
        }

        function showLoader() { 
            let loader = viewerContainer.querySelector('#loadingIndicator'); 
            if (!loader) { 
                loader = document.createElement('div'); 
                loader.className = 'loader'; 
                loader.id = 'loadingIndicator'; 
                viewerContainer.appendChild(loader); 
            } 
            loader.style.display = 'block'; 
        }
        function hideLoader() { 
            const loader = viewerContainer.querySelector('#loadingIndicator'); 
            if (loader) loader.style.display = 'none'; 
        }

        // --- Model Processing and Framing ---
        function cleanupCurrentModel() {
            if (currentModel) {
                scene.remove(currentModel);
                // Dispose of geometries and materials to free up GPU memory
                currentModel.traverse(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(cleanMaterial);
                            } else {
                                cleanMaterial(child.material);
                            }
                        }
                    }
                });
                currentModel = null;
            }
            if (mixer) { 
                mixer.stopAllAction(); // Stop all animations
                mixer = null; 
            }
        }

        function cleanMaterial(material) {
            material.dispose(); // Dispose the material itself
            // Dispose textures associated with the material
            for (const key of Object.keys(material)) {
                const value = material[key];
                if (value && typeof value.dispose === 'function' && value.isTexture) {
                    value.dispose();
                }
            }
        }
        
        function processLoadedModel(object, animations) {
            cleanupCurrentModel(); 
            currentModel = object;
            currentViewIndex = 0; // Reset view cycle index
        
            // --- Centering (NO SCALING) ---
            // 1. Calculate initial bounding box and center BEFORE any transformations
            const initialBox = new THREE.Box3().setFromObject(currentModel);
            const initialCenter = new THREE.Vector3();
            initialBox.getCenter(initialCenter);
        
            // 2. Center the model at the world origin
            currentModel.position.sub(initialCenter); 
            
            // 3. IMPORTANT: Update world matrix after position transformation
            currentModel.updateMatrixWorld(true); 
            
            // 4. Calculate the bounding box and sphere of the *centered, unscaled* model
            modelBoundingBox = new THREE.Box3().setFromObject(currentModel); // Store the box
            const finalSphere = new THREE.Sphere();
            modelBoundingBox.getBoundingSphere(finalSphere); 
            modelBoundingSphereRadius = Math.max(finalSphere.radius, 0.001); // Store radius, ensure minimum
                                                                        
            scene.add(currentModel);
            
            // 5. Frame the newly loaded, centered, and unscaled model
            performInitialFraming(); 
        
            // Handle animations if present
            if (animations && animations.length) {
                mixer = new THREE.AnimationMixer(currentModel);
                const action = mixer.clipAction(animations[0]); // Play the first animation
                action.play();
                showMessage("Model loaded. Animation playing.", "success");
            } else {
                showMessage("Model loaded successfully!", "success");
            }
            hideLoader();
        }

        function performInitialFraming() {
            if (!currentModel || !camera || !controls) return;

            const modelCenter = new THREE.Vector3(0, 0, 0); // Model is at origin

            if (modelBoundingSphereRadius <= 0.0001 || !isFinite(modelBoundingSphereRadius)) {
                camera.position.set(0, 1, 5); // Default position for tiny/invalid models
                controls.target.copy(modelCenter);
                camera.near = 0.1;
                camera.far = 1000;
                controls.minDistance = 0.01;
                controls.maxDistance = 10000;
                showMessage("Warning: Model has problematic dimensions. Using default view.", "info");
            } else {
                const radius = modelBoundingSphereRadius;
                const fovInRadians = THREE.MathUtils.degToRad(camera.fov);
                
                // Calculate distance to encompass the sphere
                let distance = radius / Math.sin(fovInRadians / 2); // distance to fit sphere based on vertical FOV
                distance = distance * 1.5; // Add 50% padding so model is not edge-to-edge

                // Position camera directly back along Z, slightly elevated using radius as a guide
                camera.position.set(
                    modelCenter.x,
                    modelCenter.y + radius * 0.5, // Elevate by half the model's radius
                    modelCenter.z + distance      // Position back by the calculated distance
                );
                controls.target.copy(modelCenter); // Look at the model's center

                // Robust near/far clipping planes
                camera.near = Math.max(0.01, radius * 0.01); 
                
                camera.far = Math.max(camera.near * 2, distance + radius * 5); 

                if (camera.near >= camera.far) {
                    camera.far = camera.near * 1000; 
                }
                if (camera.near <= 0) { 
                    camera.near = 0.01;
                }

                // Robust OrbitControls limits
                controls.minDistance = Math.max(0.001, radius * 0.001); 
                controls.maxDistance = Math.max(10, distance * 20);      
            }

            camera.lookAt(controls.target);
            camera.updateProjectionMatrix();
            controls.update();

            camera.focus = camera.position.distanceTo(controls.target);
            focusDepthSlider.value = camera.focus.toFixed(1);
            focusDepthValue.textContent = camera.focus.toFixed(1);
            if (sbsMode) stereoCamera.update(camera);
        }


        function resetView() {
            if (!currentModel) {
                showMessage("No model loaded to reset view for.", "info");
                return;
            }
            performInitialFraming(); 
            showMessage("View reset to optimally frame the model.", "success");
        }
        
        function cycleView() {
            if (!currentModel) return;

            currentViewIndex = (currentViewIndex + 1) % viewVectors.length;
            const viewDirection = viewVectors[currentViewIndex].clone();
            
            const viewDistanceOffset = modelBoundingSphereRadius > 0.001 ? modelBoundingSphereRadius * 2.75 : 5; 

            const newPosition = viewDirection.multiplyScalar(viewDistanceOffset);
            camera.position.copy(newPosition);
            camera.lookAt(0, 0, 0); 
            controls.target.set(0, 0, 0); 
            controls.update();

            camera.focus = camera.position.length(); 
            focusDepthSlider.value = camera.focus.toFixed(1);
            focusDepthValue.textContent = camera.focus.toFixed(1);
            if (sbsMode) stereoCamera.update(camera);
        }

        // --- Model Loading ---
        async function loadModel(url, fileName = '') { 
            showLoader();
            const extension = (fileName.split('.').pop() || url.split('.').pop() || '').toLowerCase();
            let loader;

            switch (extension) {
                case 'glb': case 'gltf':
                    loader = new GLTFLoader();
                    try {
                        const gltf = await loader.loadAsync(url); 
                        const texturePromises = [];
                        gltf.scene.traverse(function (node) {
                            if (node.isMesh && node.material) {
                                const materials = Array.isArray(node.material) ? node.material : [node.material];
                                materials.forEach(material => { 
                                    if (material.isMeshStandardMaterial) {
                                        const specGlossData = material.userData?.gltfExtensions?.KHR_materials_pbrSpecularGlossiness;
                                        if (specGlossData && specGlossData.diffuseTexture !== undefined) {
                                            if (!material.map) { 
                                                const promise = (async () => {
                                                    try {
                                                        const textureInfo = specGlossData.diffuseTexture;
                                                        const textureIndex = textureInfo.index;
                                                        if (gltf.parser && gltf.parser.json && gltf.parser.json.textures && gltf.parser.json.textures[textureIndex]) {
                                                            const threeTexture = await gltf.parser.getDependency('texture', textureIndex);
                                                            if (threeTexture instanceof THREE.Texture) {
                                                                material.map = threeTexture; 
                                                            }
                                                        } else {
                                                             console.warn(`Texture definition not found for index ${textureIndex} in KHR_materials_pbrSpecularGlossiness.`);
                                                        }
                                                    } catch (texError) {
                                                        console.warn(`Could not load KHR_materials_pbrSpecularGlossiness diffuseTexture for material: ${material.name}`, texError);
                                                    }
                                                })();
                                                texturePromises.push(promise);
                                            }
                                        }
                                        if (material.map && material.map.colorSpace !== THREE.SRGBColorSpace) { 
                                            material.map.colorSpace = THREE.SRGBColorSpace;
                                            material.needsUpdate = true; 
                                        }
                                    }
                                });
                            }
                        });
                        await Promise.all(texturePromises); 
                        processLoadedModel(gltf.scene, gltf.animations);
                    } catch (error) {
                        onError(error, `GLTF/GLB: ${url}`);
                    }
                    break;
                case 'fbx':
                    loader = new FBXLoader();
                    loader.load(url, (object) => processLoadedModel(object, object.animations), undefined, (err) => onError(err, `FBX: ${url}`));
                    break;
                case 'stl':
                    loader = new STLLoader();
                    loader.load(url, (geometry) => {
                        const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.5, roughness: 0.5, flatShading: false });
                        geometry.computeVertexNormals(); 
                        const mesh = new THREE.Mesh(geometry, material);
                        processLoadedModel(mesh, []);
                    }, undefined, (err) => onError(err, `STL: ${url}`));
                    break;
                case 'obj':
                    loader = new OBJLoader();
                    loader.load(url, (object) => {
                        object.traverse(child => {
                            if (child.isMesh && (!child.material || (Array.isArray(child.material) && child.material.length === 0))) {
                                child.material = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness:0.1, roughness:0.8 });
                            }
                        });
                        processLoadedModel(object, []);
                        showMessage("OBJ loaded. Materials may require a separate .MTL file not automatically handled if not found or linked.", "info", 5000);
                    }, undefined, (err) => onError(err, `OBJ: ${url}`));
                    break;
                default:
                    onError(`Unsupported file format: .${extension}`, `File: ${fileName || url}`);
                    return;
            }
        }

        function onError(error, context = "Loading model") {
            console.error(`Error in ${context}:`, error);
            hideLoader();
            const errorMessage = error.message ? error.message : (typeof error === 'string' ? error : 'Unknown error during loading.');
            showMessage(`Error: ${errorMessage}. Check console. Context: ${context}`, "error", 7000);
        }

        // --- Control Handlers (Sliders, Buttons, Keys) ---
        function updateEyeSeparation(event) { stereoCamera.eyeSep = parseFloat(event.target.value); eyeSeparationValue.textContent = parseFloat(event.target.value).toFixed(3); }
        function updateFocusDepth(event) { camera.focus = parseFloat(event.target.value); focusDepthValue.textContent = parseFloat(event.target.value).toFixed(1); if (sbsMode) stereoCamera.update(camera); }
        function updateBgBlur(event) { const val = parseFloat(event.target.value); backgroundImageElement.style.filter = `blur(${val}px)`; bgBlurValue.textContent = `${val.toFixed(1)}px`;}
        
        function updateExposure(event) { 
            const val = parseFloat(event.target.value);
            renderer.toneMappingExposure = val;
            exposureValue.textContent = val.toFixed(2);
        }

        function updateBrightness(event) {
            const brightnessFactor = parseFloat(event.target.value);
            brightnessValue.textContent = brightnessFactor.toFixed(2);

            if (ambientLight) ambientLight.intensity = initialAmbientIntensity * brightnessFactor;
            if (keyLight) keyLight.intensity = initialKeyLightIntensity * brightnessFactor;
            if (fillLight) fillLight.intensity = initialFillLightIntensity * brightnessFactor;
        }

        function adjustBrightnessSlider(amount) {
            let currentValue = parseFloat(brightnessSlider.value);
            currentValue = Math.max(parseFloat(brightnessSlider.min), Math.min(parseFloat(brightnessSlider.max), currentValue + amount));
            brightnessSlider.value = currentValue.toFixed(2);
            brightnessSlider.dispatchEvent(new Event('input'));
        }
        
        function adjustExposureSlider(amount) {
            let currentValue = parseFloat(exposureSlider.value);
            currentValue = Math.max(parseFloat(exposureSlider.min), Math.min(parseFloat(exposureSlider.max), currentValue + amount));
            exposureSlider.value = currentValue.toFixed(2);
            exposureSlider.dispatchEvent(new Event('input'));
        }


        function handleBgImageSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => { 
                    backgroundImageElement.src = e.target.result; 
                    backgroundImageElement.style.display = 'block'; 
                    bgBlurSliderContainer.classList.remove('hidden'); 
                    updateBgBlur({target: bgBlurSlider}); 
                }
                reader.onerror = () => {
                    showMessage("Error reading background image file.", "error");
                    backgroundImageElement.style.display = 'none';
                }
                reader.readAsDataURL(file); 
                showMessage("Background image loaded.", "success");
            }
            bgImageInput.value = null; 
        }
        
        function randomizeLightAngle() {
            if (!keyLight) return;
            const distance = modelBoundingSphereRadius > 0.1 ? modelBoundingSphereRadius * 5 : 10; 
            keyLight.position.set(
                (Math.random() - 0.5) * 2 * distance, 
                Math.random() * distance,             
                (Math.random() - 0.5) * 2 * distance  
            ).normalize().multiplyScalar(distance); 
            showMessage("Light angle randomized.", "info");
        }

        function loadModelFromUrl(url) { if (!url) { showMessage("Please enter a model URL.", "error"); return; } loadModel(url); }
        function handleFileSelect(event) { const file = event.target.files[0]; if (!file) return; const objectURL = URL.createObjectURL(file); loadModel(objectURL, file.name); fileInput.value = null; }
        
        function toggleSBSMode() {
            sbsMode = !sbsMode;
            const sbsIconSVG = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`;
            const sbsExitIconSVG = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.542-7 .946-3.112 3.586-5.413 6.654-6.28M15 12a3 3 0 11-6 0 3 3 0 016 0zm6.458-3.542A16.766 16.766 0 0112 5c-1.572 0-3.082.246-4.5.688M20 4L4 20"></path></svg>`;
            sbsModeButton.innerHTML = (sbsMode ? `${sbsExitIconSVG} Exit SBS (S)` : `${sbsIconSVG} Enter SBS (S)`);
            sbsModeButton.classList.toggle('danger', sbsMode); sbsModeButton.classList.toggle('success', !sbsMode);
            sbsSlidersContainer.classList.toggle('hidden', !sbsMode);
            onWindowResize(); 
        }
        function toggleFullscreen() { 
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) { 
                const el = viewerContainer; 
                if (el.requestFullscreen) el.requestFullscreen().catch(err => showMessage(`Error entering fullscreen: ${err.message}`, "error"));
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen().catch(err => showMessage(`Error entering fullscreen: ${err.message}`, "error"));
                else if (el.mozRequestFullScreen) el.mozRequestFullScreen().catch(err => showMessage(`Error entering fullscreen: ${err.message}`, "error"));
                else if (el.msRequestFullscreen) el.msRequestFullscreen().catch(err => showMessage(`Error entering fullscreen: ${err.message}`, "error"));
            } else { 
                if (document.exitFullscreen) document.exitFullscreen().catch(err => showMessage(`Error exiting fullscreen: ${err.message}`, "error"));
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen().catch(err => showMessage(`Error exiting fullscreen: ${err.message}`, "error"));
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen().catch(err => showMessage(`Error exiting fullscreen: ${err.message}`, "error"));
                else if (document.msExitFullscreen) document.msExitFullscreen().catch(err => showMessage(`Error exiting fullscreen: ${err.message}`, "error"));
            } 
        }
        
        function handleFullscreenChange() { 
            isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); 
            
            controlsWrapper.classList.toggle('fullscreen-hide', isFullscreen);
            headerPageWrapper.classList.toggle('fullscreen-hide', isFullscreen);
            footerPageWrapper.classList.toggle('fullscreen-hide', isFullscreen);

            if (isFullscreen) {
                viewerContainer.classList.add('fullscreen-active');
            } else {
                viewerContainer.classList.remove('fullscreen-active');
            }
            setTimeout(onWindowResize, 50); 
        }

        function onWindowResize() {
            let newWidth, newHeight;
            if (viewerContainer.classList.contains('fullscreen-active')) { 
                newWidth = window.innerWidth; 
                newHeight = window.innerHeight; 
            } else { 
                newWidth = viewerContainer.clientWidth; 
                newHeight = viewerContainer.clientHeight; 
            }
            
            if (camera && newWidth > 0 && newHeight > 0) { 
                camera.aspect = sbsMode ? (newWidth / 2) / newHeight : newWidth / newHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) { 
                 renderer.setSize(newWidth, newHeight);
            }
        }

        // --- Animation Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const delta = clock.getDelta(); 
            controls.update(); 
            if (mixer) { mixer.update(delta); } 

            if (sbsMode) {
                stereoCamera.update(camera); 
                const width = renderer.domElement.width / renderer.getPixelRatio(); 
                const height = renderer.domElement.height / renderer.getPixelRatio();
                
                renderer.setScissorTest(true); 
                renderer.setScissor(0, 0, width / 2, height); 
                renderer.setViewport(0, 0, width / 2, height); 
                renderer.render(scene, stereoCamera.cameraL);
                renderer.setScissor(width / 2, 0, width / 2, height); 
                renderer.setViewport(width / 2, 0, width / 2, height); 
                renderer.render(scene, stereoCamera.cameraR);
                renderer.setScissorTest(false); 
            } else {
                const width = renderer.domElement.width / renderer.getPixelRatio(); 
                const height = renderer.domElement.height / renderer.getPixelRatio();
                renderer.setViewport(0, 0, width, height); 
                renderer.setScissorTest(false); 
                renderer.render(scene, camera);
            }
        }

        // --- Keyboard Shortcuts ---
        function handleKeydown(event) {
            if (event.target.tagName === 'INPUT' && event.key !== 'Enter') return;
            if (event.target === modelUrlInput && event.key === 'Enter') {
                 event.preventDefault();
                 loadUrlButton.click();
                 return;
            }

            const sbsEyeStepFine = 0.001, sbsEyeStepCoarse = 0.01;
            const sbsFocusStepFine = 0.1, sbsFocusStepCoarse = 1.0;
            const bgBlurStepFine = 0.1, bgBlurStepCoarse = 1.0;       
            const exposureStep = 0.05;
            const brightnessStep = 0.1; // Step for overall brightness slider via keys
            let actionPerformed = false;

            if (event.shiftKey) {
                switch(event.key.toUpperCase()) {
                    case 'A': eyeSeparationSlider.value = Math.max(parseFloat(eyeSeparationSlider.min), parseFloat(eyeSeparationSlider.value) - (event.altKey ? sbsEyeStepCoarse : sbsEyeStepFine)).toFixed(3); eyeSeparationSlider.dispatchEvent(new Event('input')); actionPerformed=true; break;
                    case 'D': eyeSeparationSlider.value = Math.min(parseFloat(eyeSeparationSlider.max), parseFloat(eyeSeparationSlider.value) + (event.altKey ? sbsEyeStepCoarse : sbsEyeStepFine)).toFixed(3); eyeSeparationSlider.dispatchEvent(new Event('input')); actionPerformed=true; break;
                    case 'W': focusDepthSlider.value = Math.min(parseFloat(focusDepthSlider.max), parseFloat(focusDepthSlider.value) + (event.altKey ? sbsFocusStepCoarse : sbsFocusStepFine)).toFixed(1); focusDepthSlider.dispatchEvent(new Event('input')); actionPerformed=true; break;
                    case 'S': focusDepthSlider.value = Math.max(parseFloat(focusDepthSlider.min), parseFloat(focusDepthSlider.value) - (event.altKey ? sbsFocusStepCoarse : sbsFocusStepFine)).toFixed(1); focusDepthSlider.dispatchEvent(new Event('input')); actionPerformed=true; break;
                    case 'Z': if (!bgBlurSliderContainer.classList.contains('hidden')) { bgBlurSlider.value = Math.max(parseFloat(bgBlurSlider.min), parseFloat(bgBlurSlider.value) - (event.altKey ? bgBlurStepCoarse : bgBlurStepFine)).toFixed(1); bgBlurSlider.dispatchEvent(new Event('input')); actionPerformed=true;} break;
                    case 'C': if (!bgBlurSliderContainer.classList.contains('hidden')) { bgBlurSlider.value = Math.min(parseFloat(bgBlurSlider.max), parseFloat(bgBlurSlider.value) + (event.altKey ? bgBlurStepCoarse : bgBlurStepFine)).toFixed(1); bgBlurSlider.dispatchEvent(new Event('input')); actionPerformed=true;} break;
                    case '=': 
                    case '+': 
                        adjustBrightnessSlider(0.5); actionPerformed = true; break;
                    case '_': 
                    case '-': 
                        adjustBrightnessSlider(-0.5); actionPerformed = true; break;
                    case 'E': 
                        adjustExposureSlider(exposureStep); actionPerformed=true; break;
                    case 'Q': 
                        adjustExposureSlider(-exposureStep); actionPerformed=true; break;
                    case '.': // Shift + . (period) for brightness up
                         adjustBrightnessSlider(brightnessStep * (event.altKey ? 5 : 1)); actionPerformed = true; break;
                    case 'M': // Shift + M for brightness down
                         adjustBrightnessSlider(-brightnessStep * (event.altKey ? 5 : 1)); actionPerformed = true; break;
                }
            } else if (event.altKey) { 
                 switch(event.key.toUpperCase()) {
                    case 'L': 
                        randomizeLightAngle(); actionPerformed = true; break;
                 }
            } else { 
                switch(event.key.toUpperCase()) {
                    case 'L': if (document.activeElement !== modelUrlInput) { modelUrlInput.focus(); modelUrlInput.select(); actionPerformed = true; } break; 
                    case 'O': loadFileButton.click(); actionPerformed = true; break;
                    case 'R': centreButton.click(); actionPerformed = true; break; 
                    case 'V': changeViewButton.click(); actionPerformed = true; break; 
                    case 'B': loadBgButton.click(); actionPerformed = true; break; 
                    case 'S': sbsModeButton.click(); actionPerformed = true; break; 
                    case 'F': fullscreenButton.click(); actionPerformed = true; break;
                    case 'ESCAPE': 
                        if (isFullscreen) { toggleFullscreen(); actionPerformed = true; }
                        break;
                }
            }
            if(actionPerformed) event.preventDefault(); 
        }

        // --- Cleanup on Page Unload ---
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            cleanupCurrentModel(); 
            if (renderer) {
                renderer.dispose(); 
                if (renderer.domElement && renderer.domElement.parentElement) {
                     renderer.domElement.parentElement.removeChild(renderer.domElement); 
                }
            }
            if(scene) {
                if (scene.environment && scene.environment.dispose) {
                    scene.environment.dispose();
                }
                scene.traverse(o => { 
                    if (o.isMesh) { 
                        if (o.geometry) o.geometry.dispose(); 
                        if (o.material) {
                            if (Array.isArray(o.material)) o.material.forEach(m => cleanMaterial(m));
                            else cleanMaterial(o.material);
                        }
                    }
                });
            }
            window.removeEventListener('resize', onWindowResize);
            document.removeEventListener('keydown', handleKeydown);
            document.removeEventListener('fullscreenchange', handleFullscreenChange);
            document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
            document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
        });

        // Start the application
        init();
    </script>
</body>
</html>
